# ! /usr/bin/env python
# -*- coding: utf-8 -*-
# ===================================================================
# proofs.py
#
# 03.09.2019, Benjamin Kromer <benjamin.kromer1@web.de>
#
# @desc: Interactive and non-interactive Zero-Knowledge Proof of Logarithm
#        Knowledge DLOG(a,b) such that b=ax and Zero-Knowledge Proof of
#        Logarithm Equality DLEQ(a,b,c,d) such that b=ax and d=cx,
#        for prover's secret value x.
# ===================================================================
from ECCGT.eccwrapper import Fastecdsa as ECCobj
from ECCGT.eccwrapper import ShortPoint


class PokProver:
    """Prover in Elliptic Curve Zero Knowledge Proof of Logarithm Knowledge
    DLOG(a, b) such that b = ax

    Attributes:
        curve: elliptic curve
        a (ShortPoint): elliptic curve point
        b (ShortPoint): elliptic curve point
        x (int): secret value
        rand_par (int): random parameter
        commitment (ShortPoint): commitment from prover
        challenge (int): challenge from verifier
        response (int): response from prover
    """

    def __init__(self, curve: ECCobj, a, b, x):
        """
        Args:
            curve: elliptic curve
            a (ShortPoint): elliptic curve point
            b (ShortPoint): elliptic curve point
            x (int): secret value
        """
        self.curve: ECCobj = curve
        self.a = a
        self.b = b
        self.x = x

        self.rand_par = None
        self.commitment = None
        self.challenge = None
        self.response = None

    def pok_round1(self):
        """First round, generate commitment = rand_par * a

        Returns:
            ShortPoint: commitment
        """
        self.rand_par = self.curve.rand_gen.get_random_value()
        self.commitment = self.curve.multiplication(self.rand_par, self.a)

        return self.commitment

    def pok_round3(self, challenge):
        """Third round, generate response = rand_par - challenge*x mod order

        Args:
            challenge (int): challenge from verifier

        Returns:
            int: response
        """
        self.challenge = challenge
        self.response = (self.rand_par - self.x * self.challenge) \
            % self.curve.order

        return self.response

    def pok_nizk(self):
        """Non-interactive DLOG, challenge is generated by hash

        Returns:
            [int, int]: challenge, response
        """
        self.commitment = self.pok_round1()
        challenge = self.curve.rand_gen.get_random_from_hash(
            1, self.curve.order, 1, self.a.x, self.a.y, self.b.x, self.b.y,
            self.commitment.x, self.commitment.y)
        self.response = self.pok_round3(challenge[0][0])
        return [self.challenge, self.response]


class PokVerifier:
    """Verifier in Elliptic Curve Zero Knowledge Proof of Logarithm Knowledge
    DLOG(a, b) such that b = ax

    Attributes:
        curve: elliptic curve
        a (ShortPoint): elliptic curve point
        b (ShortPoint): elliptic curve point
        commitment (ShortPoint): commitment from prover
        challenge (int): challenge from verifier
        response (int): response from prover
    """

    def __init__(self, curve: ECCobj, a, b):
        """
        Args:
            curve: elliptic curve
            a (ShortPoint): elliptic curve point
            b (ShortPoint): elliptic curve point
        """
        self.curve = curve
        self.a = a
        self.b = b

        self.commitment = None
        self.challenge = None
        self.response = None

    def pok_round2(self, commitment: ShortPoint):
        """Second round, verifier choose challenge from 1,...,order-1 randomly

        Args:
            commitment (ShortPoint): commitment from prover

        Returns:
            int: random challenge
        """
        self.commitment = commitment
        self.challenge = self.curve.rand_gen.get_random_value()

        return self.challenge

    def pok_round4(self, response):
        """Verification check if commitment == a*response + b*challenge

        Args:
            response (int): response from prover

        Returns:
            bool: True if the equation holds, False else
        """
        self.response = response

        var0 = self.curve.multiplication(self.response, self.a)
        var1 = self.curve.multiplication(self.challenge, self.b)
        var2 = self.curve.addition(var0, var1)

        if self.commitment == var2:
            return True
        else:
            return False

    def pok_nizk(self, challenge, response):
        """Verification non-interactive DLOG, c' = a*response + b*challenge
        check if challenge = Hash(a||b||c')

        Args:
            challenge (int): challenge from prover
            response (int): response from prover

        Returns:
            bool: True if the equation holds, False else
        """
        self.challenge = challenge
        var0 = self.curve.multiplication(response, self.a)
        var1 = self.curve.multiplication(self.challenge, self.b)
        var2 = self.curve.addition(var0, var1)
        var3 = self.curve.rand_gen.get_random_from_hash(
            1, self.curve.order, 1, self.a.x, self.a.y, self.b.x, self.b.y,
            var2.x, var2.y)
        if self.challenge == var3[0][0]:
            return True
        else:
            return False


class PeqProver:
    """Prover in Elliptic Curve Zero Knowledge Proof of Logarithm Equality
        DLEQ(a, b, c, d) such that b = ax, d = cx

    Attributes:
        curve: elliptic curve
        a (ShortPoint): elliptic curve point
        b (ShortPoint): elliptic curve point
        c (ShortPoint): elliptic curve point
        d (ShortPoint): elliptic curve point
        x (int): secret value
        rand_par (int): random parameter
        commitment_1 (ShortPoint): commitment 1 from prover
        commitment_2 (ShortPoint): commitment 2 from prover
        challenge (int): challenge from verifier
        response (int): response from prover
    """

    def __init__(self, curve: ECCobj, a, b, c, d, x):
        """
        Args:
            curve: elliptic curve
            a (ShortPoint): elliptic curve point
            b (ShortPoint): elliptic curve point
            c (ShortPoint): elliptic curve point
            d (ShortPoint): elliptic curve point
            x (int): secret value
        """
        self.curve = curve
        self.a = a
        self.b = b
        self.c = c
        self.d = d
        self.x = x

        self.rand_par = None
        self.commitment_1 = None
        self.commitment_2 = None
        self.challenge = None
        self.response = None

    def peq_round1(self):
        """First round, generate commitment_1 = rand_par * a and
        commitment_1 = rand_par * c

        Returns:
            ShortPoint, ShortPoint: commitment 1 and commitment 2
        """
        self.rand_par = self.curve.rand_gen.get_random_value()

        self.commitment_1 = self.curve.multiplication(self.rand_par, self.a)
        self.commitment_2 = self.curve.multiplication(self.rand_par, self.c)

        return self.commitment_1, self.commitment_2

    def peq_round3(self, challenge):
        """Third round, generate response = rand_par - challenge*x mod order

        Args:
            challenge (int): challenge from verifier

        Returns:
            int: response
        """
        self.challenge = challenge
        self.response = (self.rand_par - self.x * self.challenge) % \
            self.curve.order

        return self.response

    def peq_nizk(self):
        """Non-interactive DLEQ, challenge is generated by hash

        Returns:
            [int, int]: challenge, response
        """
        self.commitment_1, self.commitment_2 = self.peq_round1()
        challenge = self.curve.rand_gen.get_random_from_hash(
            1, self.curve.order, 1, self.a.x, self.a.y, self.b.x, self.b.y,
            self.c.x, self.c.y, self.d.x, self.d.y, self.commitment_1.x,
            self.commitment_1.y, self.commitment_2.x, self.commitment_2.y)
        self.response = self.peq_round3(challenge[0][0])
        return [self.challenge, self.response]


class PeqVerifier:
    """Verifier in Elliptic Curve Zero Knowledge Proof of Logarithm Equality
    DLEQ(a, b, c, d) such that b = ax, d = cx

    Attributes:
        curve: elliptic curve
        a (ShortPoint): elliptic curve point
        b (ShortPoint): elliptic curve point
        c (ShortPoint): elliptic curve point
        d (ShortPoint): elliptic curve point
        commitment_1 (ShortPoint): commitment 1 from prover
        commitment_1 (ShortPoint): commitment 1 from prover
        challenge (int): challenge from verifier
        response (int): response from prover
    """

    def __init__(self, curve, a, b, c, d):
        """
        Args:
            curve: elliptic curve
            a (ShortPoint): elliptic curve point
            b (ShortPoint): elliptic curve
            c (ShortPoint): elliptic curve point
            d (ShortPoint): elliptic curve point
        """
        self.curve = curve
        self.a = a
        self.b = b
        self.c = c
        self.d = d

        self.commitment_1 = None
        self.commitment_2 = None

        self.challenge = None
        self.response = None

    def peq_round2(self, commitment_1, commitment_2):
        """Second round, verifier choose challenge from 1,...,order-1 randomly

        Args:
            commitment_1 (ShortPoint): commitment 1 from prover
            commitment_2 (ShortPoint): commitment 2 from prover
        Returns:
            int: random challenge
        """
        self.commitment_1 = commitment_1
        self.commitment_2 = commitment_2

        self.challenge = self.curve.rand_gen.get_random_value()

        return self.challenge

    def peq_round4(self, response):
        """Verification check if commitment_1 == a*response + b*challenge
        and if commitment_2 == c*response + d*challenge

        Args:
            response (int): response from prover

        Returns:
            bool: True if the equations hold, False else
        """
        self.response = response

        var0 = self.curve.multiplication(self.response, self.a)
        var1 = self.curve.multiplication(self.challenge, self.b)
        var2 = self.curve.addition(var0, var1)

        if self.commitment_1 != var2:
            return False

        var0 = self.curve.multiplication(self.response, self.c)
        var1 = self.curve.multiplication(self.challenge, self.d)
        var2 = self.curve.addition(var0, var1)

        if self.commitment_2 != var2:
            return False

        return True

    def peq_nizk(self, challenge, response):
        """Verification non-interactive DLEQ, c' = a*response + b*challenge
        and c'' = c*response + d*challenge
        check if challenge = Hash(a||b||c||d||c'||c'')

        Args:
            challenge (int): challenge from prover
            response (int): response from prover

        Returns:
            bool: True if the equations hold, False else
        """
        self.challenge = challenge

        var0 = self.curve.multiplication(response, self.a)
        var1 = self.curve.multiplication(self.challenge, self.b)
        var2 = self.curve.addition(var0, var1)

        var3 = self.curve.multiplication(response, self.c)
        var4 = self.curve.multiplication(self.challenge, self.d)
        var5 = self.curve.addition(var3, var4)

        var6 = self.curve.rand_gen.get_random_from_hash(
            1, self.curve.order, 1, self.a.x, self.a.y, self.b.x, self.b.y,
            self.c.x, self.c.y, self.d.x, self.d.y, var2.x, var2.y, var5.x,
            var5.y)

        if self.challenge == var6[0][0]:
            return True
        else:
            return False
